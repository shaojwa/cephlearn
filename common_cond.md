#### 条件变量使用

条件变量，顾名思义就是，等某个条件满足之后线程才执行某部分代码。为什么要等，为了多线程之间的同步。当一个线程等一个条件时，有2种选择。

    （1）一直等到条件满足，条件不满足，线程就挂起。就是pthread_cond_wait。
    （2）线程等一定的时间，等不到就继续走。就是pthread_cond_timedwait。
    
 一个线程怎么通知另外一个等待的线程呢？也有2种选择：
  
     （1）pthread_cond_signal()
      (2) pthread_cond_broadcast()
      
#### 为啥要有互斥量
 
一般理解下，多个线程可以等一个cond，如果一个线程等到了，该线程执行后续的代码即可，没等到的线程继续等，或者执行其他流程。为什么非要有互斥量？

《unix环境高级编程》上的说明是，【检查条件变量是否满足，如果不满足时把调用线程放到等待条件的线程列表上】这个操作需要原子性，这两个操作都在持有mutex的时候进行，而pthread_cond_signal()得调用也会在持有mutex之后进行，所以这就把两个操作串行化。

而 posix man 上的说明是：这个函数会把（1）释放锁以（2）线程阻塞在条件变量上原子化。也就是说如果一个线程a已经释放mutex并且即将要阻塞时，此时如果另外一个线程b可以获取mutex，那么线程b后续通过pthread_cond_signal()以及pthread_cond_broadcast()来通知条件改变时，是一定在a进入休眠之后进行。


此时接口没有返回。当接口成功返回时，这个调用线程将再次持有这个互斥锁。

#### 注意点

（1）一个条件变量对应一个而唯一的mutex，一个cond 对应多个 mutex的行为是不确定的。



### Cond类分析

#### 概述

ceph中使用的条件变量。是对glibc中类型pthread_cond_t的封装，用于多线程之间的同步。

#### Cond()

对应 pthread_cond_init()，从man中的描述可以知道，条件变量是一种同步的手段，它允许线程挂起，并放弃cpu，直到某些预置的条件得到满足。针对条件变量的基本操作有，通知条件变量，等待条件变量，挂起线程直到别的线程往条件变量发信号。

### ~Cond()

对应pthread_cond_destroy()

#### pthread_cond_signal

会重新启动一个正在等待条件变量的线程。如果没有正在等的线程，那什么都不会发生。如果有多个正在等的线程，只有一个会重启，但是并不指明是哪个线程。

#### pthread_cond_wait

这个调用会释放锁，同时会等在条件变量条件满足，这两者是原子性的，表明不会在释放锁和等待条件变量之间，有其他的线程释放锁并发送信号（如果这样的话，调用该接口的线程可能就再也等不到信号）。所以原子性是为了避免这个。
同时，这个调用会一直等到条件变量满足同时再次请求锁。

#### pthread_cond_timedwait

超时等待，在一定的时间内如果条件变量没有得到满足，则会再次尝试获取锁，并且返回ETIMEDOUT。所以，其实是有么能超时之后获取不到锁的，这就会有死锁。所以一般都是预期在一定时间，别的线程一定会处理完某些操作。这样调用线程就能再次获取到锁。

#### 为什么条件变量必须集合一个互斥量一起使用。

目的还是为了保护数据，互斥访问，所以互斥是必须要的，只是这里需要条件变量来触发。
所以条件变量只是在某些条件满足的情况下去获取互斥量。
两个wait接口，在调用的时候都必须先获取到互斥量，然后一个是释放锁，等待条件满足然后再次获取锁。
timedwait只不过是在超时之后再次尝试获取锁。
