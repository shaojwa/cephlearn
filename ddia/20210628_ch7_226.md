## 事务隔离级别

什么是事务隔离级别呢？严格来说事务应该是要ACID的，包括完全隔离性的。隔离性就是无法让别的事务看到当前事务的中间状态！隔离其实是很严格的一个东西。
严格意味着低性能。但是很多时候，厂商是不原因牺牲这个性能的，估计付出是在有点大。那么我们就会考虑，我们能不能不需要那么强的隔离性，这时候，我们就会有很多牺牲一定隔离性下的选择。

在做这些选择之前，我们先了解一下，隔离性相关的常见问题有哪些？

（1）别的事务写了一半之后终止，另一个事务应该看不到这写了一半的状态，如果可以看到，那就是读了脏的数据，叫脏读。

（2）如果两个事务都在写同一个对象，那么我们并不知道这两个事务的先后顺序，出现一个事务把另外一个事务的部分数据覆盖？如果会，那就是脏写。

脏读脏写是常见的隔离性没做好导致的问题，解决方案也有不少。 比如（读-提交）级别，这种级别是要求，事务之后提交之后，才能被别的事务看到。
这种级别可以防止脏读，同时也一定可以防止脏写。我的问题是，那么提交有一半的状态么？提交时原子的么？有没有提交出现一半的情况？估计一半就是失败。


读-提交隔离并不能解决计数器竞争问题！因为计数器的自增分成了读写两个事务，并不在一个事务中！


## （读-提交）锁的实现
一般通过行级锁，或者叫对象所来控制对同一个对象写入的串行。这解决的是脏写问题。而脏读，是需要双版本（这是我自取的名字）来解决。

## （读-提交）锁的问题
这个问题就是我之前想的，提交会不会也有中间状态，意思是，提交之后，数据库在真正执行之间，这个时间点去查询数据。
因为正真执行提交，可能需要一段时间，而在这个期间，你不能完全禁止查询。正式这个中间时间点的存在，导致这个时候的查询可能出现不一致。
这似乎关联到ACID中的C了，尽管是事务，但是因为提交时间的问题，导致查询结果不满足一致性。

## 快照级别隔离
既然提交导致执行无法再很短的时间内完成，即使是原子的，但是如果隔离性做的不好，就会影响一致性。
