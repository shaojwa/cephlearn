#### 工作函数中不获取锁，接口函数中获取锁
```
Journaler::wait_for_flush() -> _wait_for_flush()
Journaler::flush() -> _flush()
```

#### 一个值获取用返回值，多个之获取用容器引用

获取一个值：
```
inodeno_t InoTable::project_alloc_id(inodeno_t id) 
```
获取多个值：
```
void InoTable::project_alloc_ids(interval_set<inodeno_t>& ids, int want) 
```

## CDir中的为什么两个get_inode()函数
因为要修改，所以需要对开放开，但是提供const函数可以尽可能减少被误修改的风险。
```
CInode *get_inode()   { return inode; }
const CInode *get_inode() const { return inode; }
``` 
diri = dir->get_inode() 调用时会根据dir是不是const指针进行选择，如果dir是const指正，那么编译时只会调用第二个接口。
所以，而如果CInode中获取字段的接口如果没有const属性，就不能调用，所以代码中很多时候以diri->inode的方式直接访问字段。

#### 根据字段类型返回字段名接口
```
// 直接用static const char *，并且switch-case中直接return
static inline const char *get_lock_action_name(int a)
```

#### ceph中有strict_strtol系列函数将string转为整数
``` 
int level = (int) strict_strtol(levelstr.c_str(), 10, &err);
```

#### ceph中有get_str_vec接口来处理将string分割为vector
```
vector<string> kvs;
get_str_vec(config, ",",  kvs);
```
