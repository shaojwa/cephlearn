https://docs.ceph.com/docs/master/dev/cephfs-snapshots/

## 有备份为什么需要快照

备份期间，常常是不允许进行业务的，随着数据越来越大，这个需要暂暂停的时间会越来越长，所以希望这个时间窗口缩小，越小越好。
所以才有快照，持续数据保护等技术出现。

## 优势

在数秒内完成恢复

## 分类

全量快照
增量快照

## 增量快照基本原理

基本的数据结构角度来说，有4部分，源数据卷，快照数据卷，源数据指针表，快照数据指针表。
源数据指针表和快照数据指针表就是数据的元数据，用来指向数据的位置。

新数据N，原有数据P，打快照时有两种选择：（1）马上把原有数据拷贝出去，这样原有对象就可以写新的数据。但是这样的话，快照操作耗时很多，因为需要原有的数据拷贝完成之后再返回。（2）先标记，不拷数据，有新数据时再处理。（2）显然更快，但是写入数据时，要么需要重定向，要么需要复制数据。

如果要修改时处理POW，那么又分两种，（a）拷贝原有数据到新的地方，原有位置写新数据，写入不需要重定向到其他位置（COW）。
所以从数据结构角度来说，COW的方式中，源数据指针表从未变化，变化的是快照数据指针表。

（b）直接写入新的位置，这样就不需要拷贝，就是重定向到新的对象，这时候因为有重定向，所以数据的数据的元数据有更改（ROW）。
这种方式下，源数据指针表会发送变化（因为重定向到新的位置），所以在因为写操作触发ROW的时候，原来的老数据只能读，新的数据写到增量块中。
这种方式导致新的数据是不连续的，增量快照的是新的数据，而不是CROW那样的老的数据。因此这种方式是链式的，因为新的数据都在快照卷中。

比较COW和ROW，主要区别是，COW的新数据在源卷中，而ROW的新数据在镜像卷中。

在多次写入之后，在获取到最新的数据时，ROW的数据就会比较分散，连续读写性能不是很好，因为最新数据不再同一块位置。而COW的最新数据还在原来的位置，性能很好，只是快照的位置不连续，恢复快照的时间比较久。其实这两种方式总的数据块数量是一样的，只是如果你想让新数据连续，就必须把数据拷贝出去，因为要覆盖，所以可能会多出一倍的写用时。

但是以上分析也知道，对于分布式系统来说，业务层的连续性没有用，数据都是分散存储的，所以在分布式系统中，ROW的表现会更加出色。据说也是业界发展的主要方向。

## 具体用法

#### 创建

先开启该特性 `ceph mds set allow_new_snaps true --yes-i-really-mean-it`

#### 恢复

ceph 没有提供原生的恢复接口

每个目录下都有一个.snap目录

## 实现方式

* 快照域作为inode的一部分进行编码。
* 打过快照的元数据存储在一个叫做 old_inodes这个map中，一个版本的快照信息存放在old_inode_t这个结构中。
* 快照的元数据在底层RADOS自己处理。

#### 文件快照实现流程

流程都是同一个，只是有一个inode号 +　快照版本号。

#### 为什么有一个snapid叫CEPH_SNAPDIR

因为head对象被删掉，但是clone对象还在，snapset这个元数据需要存放，这个元数据本来存放在head对象的xattr中，现在head对象被删掉，需要有一个对象来存放原snapset数据。
所以需要有这么个对象，OSD中的SNAPDIR和文件里的.snapdir没有关系。

#### 文件快照
1. 对一个文件来说，打快照是基于文件的，但是一个文件可能由多个快照组成，那么只有对某个对象的写操作才会触发对象快照的创建。
1. 所以，OSDC中的SnapContext是维护整个的，一次快照，seq就增加。这个SnapContext会下发到具体的某个对象，和对象内部的SnapSet进行比对。
1. 文件系统中，一个文件打过快照（假设seq为5）之后，再次写入导致COW时，文件的head就会变成\[6, HEAD\]，快照为\[2, 5\]

#### 目录快照
1. 一个目录，假如原先这个目录的CInode中的信息是\[2, head\]，打快照，比如seq=5，之后，目录属性改变，比如chmod。
那么，目录的dentry对应的inode结构中，就会把 `{5, (2,inodedata)}` 放到old_inodes中。
其中5表示打快照时的seq，2表示原先的first。这样file的CInode，CInode最新的first就会变成6。
1. 目录改名才会触发CDentry中first和last的变化。

#### MDS中的CInode/CDentry/CDir
CInode/CDentry都是有实体对应的CDir没有，但是为什么CInode/CDentry有first和last，CDir只有first。

#### 文件系统的COW为什么要设计成两套机制
文件系统中，文件也好目录也好，都关联两个东西，一个是dentry，一个是inode。但是在ceph中，快照的实现在文件和目录上并不相同。

文件打了快照，然后写数据，写数据带来元数据的改变，文件inode中的size会发生变化。
会生成新的inode和dentry。新的dentry中的last就是快照号，老的inode中的first变成snap_id + 1, last变成head。
新的inode中的last是快照号。老的inode中的first是snap_id+1，last还是head。这是文件COW之后write操作带来的变化。

但是目录不一样，对于目录来说，目录的写入可以是目录中多创建一个子文件或者目录。
或者目录本身被chmod，因为chmod改变的是目录inode中的uid和gid。
反正就是目录的inode被改变。此时目录的dentry并没有和文件一样，创建一个新的。
目录的inode也同样没有创建一个新的。而只是把原来的数据放到inode结构中的old_inodes中。

为什么要这样? 现在我还不清楚

#### 文件系统中的inode的first为什么需要等于最新快照号+1
