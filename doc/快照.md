https://docs.ceph.com/docs/master/dev/cephfs-snapshots/

## 有备份为什么需要快照

备份期间，常常是不允许进行业务的，随着数据越来越大，这个需要暂暂停的时间会越来越长，所以希望这个时间窗口缩小，越小越好。
所以才有快照，持续数据保护等技术出现。

## 优势

在数秒内完成恢复

## 分类

全量快照
增量快照

## 增量快照基本原理

基本的数据结构角度来说，有4部分，源数据卷，快照数据卷，源数据指针表，快照数据指针表。
源数据指针表和快照数据指针表就是数据的元数据，用来指向数据的位置。

新数据N，原有数据P，打快照时有两种选择：（1）马上把原有数据拷贝出去，这样原有对象就可以写新的数据。但是这样的话，快照操作耗时很多，因为需要原有的数据拷贝完成之后再返回。（2）先标记，不拷数据，有新数据时再处理。（2）显然更快，但是写入数据时，要么需要重定向，要么需要复制数据。

如果要修改时处理POW，那么又分两种，（a）拷贝原有数据到新的地方，原有位置写新数据，写入不需要重定向到其他位置（COW）。
所以从数据结构角度来说，COW的方式中，源数据指针表从未变化，变化的是快照数据指针表。

（b）直接写入新的位置，这样就不需要拷贝，就是重定向到新的对象，这时候因为有重定向，所以数据的数据的元数据有更改（ROW）。
这种方式下，源数据指针表会发送变化（因为重定向到新的位置），所以在因为写操作触发ROW的时候，原来的老数据只能读，新的数据写到增量块中。
这种方式导致新的数据是不连续的，增量快照的是新的数据，而不是CROW那样的老的数据。因此这种方式是链式的，因为新的数据都在快照卷中。

比较COW和ROW，主要区别是，COW的新数据在源卷中，而ROW的新数据在镜像卷中。

在多次写入之后，在获取到最新的数据时，ROW的数据就会比较分散，连续读写性能不是很好，因为最新数据不再同一块位置。而COW的最新数据还在原来的位置，性能很好，只是快照的位置不连续，恢复快照的时间比较久。其实这两种方式总的数据块数量是一样的，只是如果你想让新数据连续，就必须把数据拷贝出去，因为要覆盖，所以可能会多出一倍的写用时。

但是以上分析也知道，对于分布式系统来说，业务层的连续性没有用，数据都是分散存储的，所以在分布式系统中，ROW的表现会更加出色。据说也是业界发展的主要方向。

## 具体用法

#### 创建

先开启该特性 `ceph mds set allow_new_snaps true --yes-i-really-mean-it`

#### 恢复

ceph 没有提供原生的恢复接口

每个目录下都有一个.snap目录

## 实现方式

* 快照域作为inode的一部分进行编码。
* 打过快照的元数据存储在一个叫做 old_inodes这个map中，一个版本的快照信息存放在old_inode_t这个结构中。
* 快照的元数据在底层RADOS自己处理。

#### 文件快照实现流程

流程都是同一个，只是有一个inode号 +　快照版本号。
