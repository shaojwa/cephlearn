#### 总体方案

```
1. 一个节点上一个ceph-dse进程
2. ceph-dse进程中，一个ceph-dse会处理多个pool，为每个pool分配8个engine实例。
3. 每个engine实例，会有一个dcache实例，一个row实例，一个dedup实例。
4. 每个engine实例，dcache模块会映射到一个协程processor(对应一个操作系统线程)
5. 一个dcache实例对应，多个task，这些task可以在一个processor上处理，也可以在做个processor上处理。
```
现在的问题是，原来的hash是一个dcache-instance会对应一个processor，所以映射是：
```
object_id->bucket_id->engine_id->processor_id
```
如果一个dcache-instance可以在多个processor上跑，那么如何hash?   
少掉中间的engine_id的分层，所有的engine_id都对应多个processor。  
```
object_id->bucket_id->processor_id
```
问题是，一个object_id会对应一个bucket_id，然后对应到一个processor_id，一个对象最终在同一个processor_id上处理就可以。

资源分配：
```
1. 一个节点64个核，给dse32个核，32个核分割dcache，row，dedup
```

### DM 多processor 实现参考
参考get_data_obj_info() (cstore_template.h) 代码
