#### 系统的事务隔离级别。
我们常常说事务隔离级别，其实这个是系统的一个特性，而不是事务的特性，尽管我们常常说成事务四种隔离级别。
这是系统对事务执行环境的一种承诺，系统的事务隔离级别，是对ACID要求的I这个要求满足程度的描述，注意，只是针对I。

#### 隔离级别解决什么问题
隔离级别是用来描述对ACID是个属性满足程度的，用来指明这种系统到底在多大程度上满足ACID中的隔离性。

#### read-uncommitted
最低的隔离级别，read-committed，这是一种很弱的隔离级别。事务B可以读事务A中还没有提交的数据，这是脏读，这是对事务I（隔离性）要求的破坏。
为了解决这种问题，所我们需要有下一个隔离级别，read-commited。

#### read-committed
有这个这个级别，另外一个事务没有提交，你是看不到的。但是一个事务提交了，你就能看到是不是就足够呢？不是的。
这就会导致一个事务在执行过程中的两次读可能读到的数据就不一样。所以，这就会有不可重复读的问题，B事务在实行的过程中有两次读，读到的数据不一样。
因为中间A提交过。所以这就会导致不可重复读问题。这是两次读取的问题，读取不一致。

另外，因为read-committed的问题，还有会有中情况，就是幻读，我读到了本来不应该独到的数据。
比如事务B先删除了所有表项，然后读取，此时是不应该读到任何数据的。但是期间，A事务插入一行数据并提交了，此时B事务就会发现，我还能读到数据。

两者其实很类似，但是又不太一样，不可重读读是读同样的数据，前后数据不一样，针对的是update导致的不一致。
而幻读，是读到了本来可能读不到的数据，针对的是delete或者insert导致的不一致，其实这两宗也可以算作update。

#### repeatable-read
为了解决幻不可重复读的问题，我们只需要行锁，锁定这一行，其他事物就没有权限影响到这一行。这就保证你一个事务内的多次读取，都是一样的数据。
这就是达到了第三个隔离级别，可重复读。但是这还是没有解决幻读问题。因为幻读问题的解决，需要事务在实行过程中锁定整张表。
为了解决这个问题，我们需要引入最高级别的隔离，就是第四等级的隔离，叫串行化。

#### serializable
可串行化的。
