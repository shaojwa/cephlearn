#### 参考
```
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&rep=rep1&type=pdf
```
#### 摘要

1. 标准的及基于磁盘的索引结构，比如B-Tree，会成倍得增加IO开销，为什么？因为需要维护索引？
1. LSM-tree 也是基于磁盘的数据结构，在文件需要被高频率得插入或者删除记录的情况下，来提供低成本的文件索引开销。
1. LSM-tree一种算法，来延迟以及打包index的修改。
1. LSM-tree将修改从基于内存的组件，转存到一层或者多层的基于磁盘的组件中，这个过程以高效的归并排序来进行。
1. 在处理的过程中，所有的index value都是持续可访问的（除去非常短的加锁时间），要么通过内存组件，或者通过磁盘组件。
1. 和传统的类似B-Tree访问方式比起来，这个算法显著减少磁臂的移动。所以在磁道臂开销占绝大多数存储开销的场进行下，会提高性能。
1. LSM-tree这种方式也推广到除插入和删除之外的其他操作上。
1. 需要马上响应的索引查找，在某些场景下会失去一定的效率。所以 LSM-tree 在插入操作远远多于查找的情况下非常有用。

对于Histoy tables 和 logfile来说，这是一个很常见的属性。


#### 介绍

存储领域，对于非结构化的数据（kv形式）是当前非常常见的存储形式。
而kv存储的实现机制中，常见的就是LSM-tree，比如LevelDB，RocksDB。
LSM-tree最早是1996年的一篇论文《The Log-Structured Merge-Tree (LSM-Tree)》

很多引擎都是采用Log-Structured Merge-Tree 结构来做kv存储，特点是写性能很好，读性能也不错。  
LSM-tree是一种对写进行优化的实现方式，核心自然是把随机写变成顺序写。因此它的缺陷就是写放大。
机械硬盘来说，顺序写和随机写的性能据说差1000倍，所以改成顺序写的价值是很大的。

#### 关于写放大
LSM-tree的关键指标是写放大，写分好几种，有立即写和延迟写，redo log肯定是立即写，日志需要马上落盘。
而后续的异步写包括数据刷盘以及LSM-tree的compact就是延迟写。

网上看到的写放大对于RocksDB来说有42倍，levelDB也有27倍。

写放大影响设备的使用设备，能耗，以及网络带宽，所以降低写放大是很重要的一个方面，特别是现在SSD在逐步普及。

#### 关于读放大

#### 关于空间放大

#### 关于日志

对于存储系统来说，日志几乎是不可避免的。

#### 数据的插入

有数据插入，先把kv写入LogFile，然后再把kv写入内存表memtable。同时达到一定的容量后，内存表会变成只读，写入磁盘变成SSTable。
找各种SSTable达到一定的数目，比如四个，就会另外分层，这样磁盘上就会有多个level。

#### level的Compaction
这种level多了之后，因为我们知道SSTable记录的是kv操作，那么某一个key就可能有多次操作位于不同的level中，这样两个level之间就有重叠。
所以，这时候就可以进行level之间的压缩，这叫做compact。


#### LevelDB 中的compaction压缩

#### 附录

https://zhuanlan.zhihu.com/p/38810568
https://juejin.im/post/5b1f69dee51d4506d25e31ea
