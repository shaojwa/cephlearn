## CRUSH 所对应的技术点
分布式系统的基本技术角度来说，CRUSH属于数据分区策略。即，将一个对象放置在什么位置。如果层次简单，我们可以只用一层分区策略，来决定一个对象放置到什么节点。
但是，对于分布式系统来说，底层的节点往往是动态变化的，而对象的数量也非常多，直接建立对象和节点的映射也许并不是一个很好的办法。

为什么这不是一个很好的办法？因为要设计好的数据的分区策略，必然需要考虑的一个问题是数据的再平衡问题。这是和数据分布相伴随的一个问题。我们知道，数据分布策略常常有以下几种：

- 基于关键字区间分区。

这种分布和字典差不多，一个或者多个关键字分为一个区间，这个区间对应到特定的存储区域。这种分区方式的一个最直接问题是，容易产生局部热点。
关键字不加处理地进行分区，是导致这个问题的直接原因。访问本身是存在局部性的，我们需要将这种局部性消除，那么直接使用和访问信息强相关的关键字就不可避免存在这种问题。

- 基于关键字哈希值

既然关键字区间存在局部热点问题，要消除这种局部性，首先想到的就是随机化，即通过hash进行打散。hash之后，数据的分部几乎是均匀的，而且访问也几乎是均匀的。看起来很好。
但是，我们必须知道，没有绝对的更好，hash这种方式带来的明显问题是，连续范围查找（或者说区间查询）速度变慢，连续的几个关键字查找，经过hash之后，完全打散。
那么意味着连续关键字的访问是全集群范围内的查询。其实在我看来，关键字区间分区所带有的有序相邻特性并不重要，关键字连续区间的查找并不是分布式系统的性能关键点。
关键字的hash方式拥有的均衡和无序也许是一个很大的优点。无序化之后，数据分区的边界就可以均匀分布。

## CRUSH 需要解决的问题
我们明确知道，我们需要hash来打散，但是打散函数有很多，比如MD5就是一个很好的打散函数，是不是打散了就解决了分布问题？不是的。
我们有hash值，只是第一步，只是明确，我们希望避免负载倾斜。我们需要将hash值进一步和存放的位置对应起来。
如果我们有100个节点，那么怎么将打散后的值和具体的位置对应就是下一步要解决的问题。最简单的，我们可以取模，`hash % node_num = node_index`。
看起来很完美，但是存取只是一个需求，我们前面说过，任何分区分布策略，都需要考虑两点，一是数据访问，二是数据再平衡。
如果集群不会出任何故障，节点数量也不变，取模当然已经足够。但是集群是肯能发生扩容缩容，也有不可避免的故障。当节点发生变化时，数据需要重新均衡。
如果只是取模，那么大部分的hash值是会重新分布的。一旦出现故障，数据的重分布产生的带宽需求会严重影响系统的可用性。

## CRUSH的技巧

